classdef QuantViews < handle
    % The purpose of this class is to generate a structure QViews
    % summarizing all 'quant-based'  views that will be used within
    % objects of class Universe
    
    % The goal is to create a scructure Qviews having the same format as
    % the structure SubjViews generated by SubjectiveViews. For now only
    % the Mu and Corr (or Sigma) (first and second moment) are
    % contemplated, but this will be expanded to accomodate for different
    % types of views
    
    % At the moment (06/2016) the only input comes from objects of class
    % QuantSignals, but it can be expanded to incorporate several types of
    % quant views
    
    % Objects of this class are instantiated within method Dynamic_AA_1 of
    % class universe to represent Subjective and/or quant views to be then
    % considered when optimizing the asset allocation decisions over the
    % backtesting window
    
    % *** METHOD CheckSignalAtGivenTime:
    % this method is normally invoked within universe.Dynamic_AA_1: its
    % purpose is to 'detect' trading signals as of a given date, so that
    % these signals can be incorporated within the AA framework through
    % entropy pooling. Its main outputs as of tdy (28/6/2018) are:
    % Q.QViews.('view name').Mu: expected returns at the Horizon from Views
    % Q.QViews.('view name').Mu_ViewSign: sign of the inequality related
    % to the 'Mu' view
    % Q.QViews.('view name').Sigma: expected covariances at the Horizon from Views
    % Q.QViews.('view name').SigmaSign:  sign of the inequalities related
    % to the 'Sigma' view
    % **** NaN used whereas there is no view ***
    %  checkSignal.CHANGEQ(1:Q.NumberOfSubjects,1): for each view (subject)
    %  says whether there is a signal
    %  checkSignal.UNTRIGGERQ(1:Q.NumberOfSubjects,1): for each view (subject)
    %  says whether there is strategy to 'close'
    %  other fields in the struct 'checkSignal': they may vary depending on
    %  the specific strategy, so this list cannot be axhaustive
    % the struct field 'optionalParam' is used to provide further information that
    % might be nbeeded by the specific trading strategy. The
    % presence/absence of specific subfields in 'optionalParam' can shape
    % the outputs from this method in different ways
    
    properties (SetAccess = immutable)
        AlgoViews_1;
        InputParams;
        InvNameSet;
        Prior_perturbations;
        D_I_matching;
        NumberOfSubjects;
    end
    
    properties
        % expected return and cov matrix at the investmente horizon (based
        % on quant views)
        QViews;
        Mu;
        Sigma;
        ConfInQuantViews;
    end
    
    methods
        function Q = QuantViews(params)
            % params ios a struct array containing a set of info specific
            % to the quant strategy being used and needed to produce
            % generate the OUTPUT: vector of expected returns and expected
            % cov matrix at the investment horizon. In the future more
            % complex views will be defined, based on higher moments.
            
            Q.InputParams = params;
            
            % constructor selection based on the strategy: it would be
            % possible to make the code more efficient by standardizing the
            % input structure that to some extent chould be possible, but
            % for now I prefer to keep to code more readable and write
            % specifi code for each strategy, even considering that quant
            % algos and strategies in general can be very very spcific and
            % complicated to generalize
            % Notes:
            %  params.persist: when this parameter is set to true then the
            %  method 'CheckSignalAtGivenTime' receives back from
            %  Dynamic_AA_1 the vector checkSignal.CHANGEQ to 'understand'
            %  whether the specific strategy generated a trigger. If yes
            %  then the signal is kept even if it is not currently active,
            %  unless some condition (specific to the strategy) occurred to
            %  turn it off.
            
            switch params.StrategyName
                
                % *********************************************************
                % *********************************************************
                
                case 'Signal_Gen_1'
                    % unlike the EG_Coint below here only one view is built, even if more drivers can
                    % trigger signals
                    Q.NumberOfSubjects = 1;
                    Q.ConfInQuantViews = [];
                    Q.Prior_perturbations = params.Drivers.Signal_Gen_1;
                    
                    for k=1:params.drivers_no
                        S(k).Signal_ON = params.Drivers.Signal_Gen_1(k).Prior_Changes;
                        % changed 19/9/2016: starting with the first
                        % trigger I want signal to be always ON, since now
                        % the signal is checked continuously within obj of
                        % class universe and Mu and Sigma updated when the
                        % signal is active. With regard to this simple
                        % strategy the signal is always on after the first
                        % trigger
                        ffirst = find(S(k).Signal_ON == 1);
                        if ~isempty(ffirst)
                            ffirst = ffirst(1);
                            S(k).Signal_ON(ffirst:end) = 1;
                        end
                        S(k).dates = params.Drivers.Signal_Gen_1(k).dates;
                        S(k).SignalStructure = params.Drivers.Signal_Gen_1(k).SignalStructure; % needed generate signals in terms of views on moments
                    end
                    
                    ViewsNames{1,1} = 'Signal_Gen_1';
                    DynamicViews.S = S;
                    
                    % Drivers - Invariants underlying risk matching:
                    % the purpose here is to define a matrix having dimension
                    % [nD,nI], where nD is the no of drivers and nI is the no of
                    % invariants. The cell identified by (i,j) is 1 if the i-th
                    % driver is the same  as the j-th invariant
                    % This matrix will be used below to condition expected values
                    % and covariances (and even higher moments) based on the driver
                    % that generates a signal
                    
                    % TODO: SEE IN MORE DETAILS WHAT HAPPENS WHEN UNDERLYINGs ARE
                    % UNDERLYINGs TO OPTIONS
                    InvNameSet = params.InvariantsNamesSet;
                    
                    nI = size(InvNameSet,1);
                    nD = size(params.Drivers.Signal_Gen_1,2);
                    D_I_matching = zeros(nD,nI);
                    
                    for nd=1:nD
                        for ni=1:nI
                            if strcmp(params.Drivers.Signal_Gen_1(nd).Name,InvNameSet{ni,1}) ...
                                    | strcmp(params.Drivers.Signal_Gen_1(nd).UndName,InvNameSet{ni,1})
                                D_I_matching(nd,ni) = 1;
                            end
                        end
                    end
                    Q.D_I_matching = D_I_matching;
                    
                % *********************************************************
                % *********************************************************
                
                case 'CointPower'
                    % extracting from params the set of info needed within
                    % the method CheckSignalAtGivenTime to translate
                    % signals from this specific strategy into views that
                    % can be managed within universe.Dynamic_AA_1
                    
                    disp('CointPower case in QuantViews.m');
                    % Drivers can be a vector of structures, each one
                    % containing dynamic trading signals from a different
                    % cointegrated pair
                    Q.NumberOfSubjects = numel(params.Drivers.params);
                    Q.D_I_matching = []; % nou used for this strategy
                    
                    for k=1:Q.NumberOfSubjects
                        DynamicViews(k).dates = datenum(params.Drivers.Signal{k}.Data.Daily.Time);
                        DynamicViews(k).signals = params.Drivers.Signal{k}.Data.Daily.SignalsStrat_1;
                        DynamicViews(k).confidenceInSignal = params.Drivers.ConfidenceInSignal{k};
                        ViewsNames{k,1} = strrep(params.Drivers.ViewsNames{k},' ','_');
                    end
                
                % *********************************************************
                % *********************************************************
                
                case 'PairCointegration'
                    % extracting from params the set of info needed within
                    % the method CheckSignalAtGivenTime to translate
                    % signals from this specific strategy into views that
                    % can be managed within universe.Dynamic_AA_1
                    
                    disp('PairCointegration case in QuantViews.m');
                    % Drivers can be a vector of structures, each one
                    % containing dynamic trading signals from a different
                    % cointegrated pair
                    Q.NumberOfSubjects = numel(params.Drivers.params);
                    Q.D_I_matching = []; % nou used for this strategy
                    
                    for k=1:Q.NumberOfSubjects
                        DynamicViews(k).dates = datenum(params.Drivers.Signal{k}.Data.dates);
                        DynamicViews(k).signals = params.Drivers.Signal{k}.Data.SignalsStrat_1;
                        DynamicViews(k).confidenceInSignal = params.Drivers.ConfidenceInSignal{k};
                        ViewsNames{k,1} = strrep(params.Drivers.ViewsNames{k},' ','_');
                    end
                    
            end % switch
            
            Q.AlgoViews_1.DynamicViews = DynamicViews;
            Q.AlgoViews_1.ViewsNames = ViewsNames;
            Q.InvNameSet = params.InvariantsNamesSet;
            
        end % QuantViews constructor
        
        function [checkSignal] = CheckSignalAtGivenTime(Q,t,current_t_date,X_fullHistory,Horizon_Estim_Interval,optionalParam)
            % this method checks if there is a signal at a given time t. It has been conceived to be
            % called within a dynamic AA process (e.g. in methods Dynamic_AA
            % of class Universe) to check if a quant signal occurred at any
            % given time
            
            % optionalParam: this is a structure containing parameters that
            % are specific to the single strategies. For example
            % the TS 'PairCointegration'  receives the checkSignal.CHANGEQ
            % vector back from universe.Dynamic_AA_1 tu 'understand'
            % whether a given strategy was runninbg to be able to decide
            % whether to keep it running (while updating something - eg the
            % confidence level and the data) or not
            
            
            % X_fullHistory is the full history (or possibly a different
            % set), up to the current time,  of joint invariants'scenarios that will be used to define
            % views on axpected returns and correlations/covariances
            % Horizon_Estim_Interval: investment horizon needed for
            % projection
            
            % pre-assigning some of the outputs checkSignal's fields
            checkSignal.ViewLag = [];
            checkSignal.OPTIM = false(1); % used to trigger an optimization even when there are no quant signals (e.g. to enforce a new vector of weights)
            
            % checkSignal.UNTRIGGERQ = NaN;
            
            % preallocating vector of expected returns and matrix of
            % expected covariances
            % (NaN will be used to understand which elements to
            % include when converting into equalities/inequalities
            % using the method Views2Constraints of class universe
            Sigma_View = ones(size(X_fullHistory,2)).*NaN;
            Sigma_ViewSign = cell(size(X_fullHistory,2));
            Mu_View = ones(1,size(X_fullHistory,2)).*NaN;
            Mu_ViewSign = cell(1,size(X_fullHistory,2));
            RankingViews = [];
            RankingViewsSign = [];
            CONFIDENCE = [];
            
            switch Q.InputParams.StrategyName
                % ***************************************
                case 'Signal_Gen_1'
                    nassets = optionalParam.nassets;
                    % pre-assigning some of the outputs checkSignal's fields
                    checkSignal.upperWgtsLimits = optionalParam.upperWgtsLimits;
                    checkSignal.lowerWgtsLimits = optionalParam.lowerWgtsLimits;
                    checkSignal.equalityConstraintsFromQuantStratLHS = [];
                    checkSignal.equalityConstraintsFromQuantStratRHS = [];
                    checkSignal.HorizonDays = Q.InputParams.HorizonDays;
                    
                    checkSignal.UNTRIGGERQ = false(1); % not used for this strategy
                    checkSignal.CHANGEQ = false(1); % this strategy implies only 1 view even if it can rely on several drivers
                    % this is a simple algo based strategy mainly used to
                    % test how the dynamic AA process manages quant based
                    % views expressed in terms of expected returns and cov
                    % matrix at the investment horizon
                    drivers_no = Q.InputParams.drivers_no;
                    
                    for k=1:drivers_no
                        if Q.AlgoViews_1.DynamicViews.S(k).Signal_ON(t) == 1
                            checkSignal.CHANGEQ = true(1); % flag indicating change due to quant signals
                            checkSignal.ViewLag(k,1) = Q.Prior_perturbations(k).SignalStructure(t,3);
                        else
                            checkSignal.ViewLag(k,1) = 0;
                        end
                    end % k
                    
                    % if a signal has occurred the view on expected returns and
                    % covariances must be defined as of the same time t
                    if checkSignal.CHANGEQ
                        
                        % to condition the means based on specific drivers'signal
                        for k=1:drivers_no
                            % look for the invariants affected by the k-th driver
                            % (same underlying)
                            fI(k) = find(Q.D_I_matching(k,:) == 1);
                            Key(k) = fI(k) ;
                            Value(k) = k;
                            lagV(k,1) = Q.Prior_perturbations(k).SignalStructure(t,3); % identify the lag
                            type = Q.Prior_perturbations(k).SignalStructure(t,4);
                            if ~isempty(fI(k))
                              
                                used_lag = lagV(k,1); %Q.InputParams.HorizonDays*5;
                                start_t = t-used_lag;
                                if start_t<1
                                    start_t=1;
                                end
                                % s = exp(cumsum(X_fullHistory(t-used_lag+1:t,fI(k))))-1;
                                % s = diff(s,Q.InputParams.HorizonDays);
                                s = (X_fullHistory(start_t:t,fI(k)));
                                
                                
                                if type == 1 % if the proj return implied by algo Mu is > 0 I want to use scenarios where the proj ret is > than the one implied bu algo mu
                                    Mu_View(1,fI(k)) = abs(mean(s)).*Q.InputParams.HorizonDays; %0;
                                    Mu_ViewSign{1,fI(k)} = ['>'];
                                elseif type == -1  % ... and the same idea applies here
                                    Mu_View(1,fI(k)) = -abs(mean(s)).*Q.InputParams.HorizonDays; %0;
                                    Mu_ViewSign{1,fI(k)} = ['<'];
                                end
                                
                            end
                        end
                        Invariants2ViewNoMap = containers.Map(Key,Value);
                        % conditioning cov matrix (only for the pairs
                        % corresponding to pairs of drivers)
                        
                        %TODO: review and write better the cov code below
                        allpairs = combnk(fI,2); % all combination indicating pairs to be changed (and the symmetrical elements) in terms of invariants matrix
                        % adding terms for variances
                        variancesTerms = fI';
                        variancesTerms = repmat(variancesTerms,1,2);
                        allpairs = [allpairs;variancesTerms];
                        if false(1) % true(1) % false(1) to skip cov based constraints, true(1) to include them
                            for p=1:size(allpairs,1)
                                e1 = allpairs(p,1);
                                e2 = allpairs(p,2);
                                
                                % here the covariance is used based on a period
                                % that is the shorter between the times form the
                                % latest signals for the pair of invariants
                                % involved. If it is below a given threshold
                                % than the view is not implemented
                                lag_to_be_used4Covariance = min(checkSignal.ViewLag(Invariants2ViewNoMap(e1)), ...
                                    checkSignal.ViewLag(Invariants2ViewNoMap(e2)));
                                
                                start_t = t-lag_to_be_used4Covariance;
                                if start_t<1
                                    start_t=1;
                                end
                                % if t-start_t<Q.InputParams.HorizonDays*5 % less than 5 pts to estimate cov: skip
                                %   continue
                                % end
                                
                                % covariance calculated directly using
                                % Q.InputParams.HorizonDays as the lag
                                % s1 = cumsum(X_fullHistory(start_t:t,e1));
                                % s2 = cumsum(X_fullHistory(start_t:t,e2));
                                % s1 = diff(s1,Q.InputParams.HorizonDays) - Mu_View(e1);
                                % s2 = diff(s2,Q.InputParams.HorizonDays) - Mu_View(e2);
                                
                                s1 = (X_fullHistory(start_t:t,e1));
                                s2 = (X_fullHistory(start_t:t,e2));
                                
                                
                                Sigma_View(e1,e2) = ((s1'*s2)./size(s1,1)).*Q.InputParams.HorizonDays;
                                impliedCovSign = sign(Sigma_View(e1,e2)); % cov sign implied by the Mu's signals
                                
                                % **********************************************
                                % to set a target in terms of cov starting from
                                % a target based on corr
                                abs_target_corr = 0; %1 ************************
                                target_corr = abs_target_corr.*impliedCovSign;
                                sd1 = std(s1); sd2 = std(s2);
                                targetCorr = [1,target_corr;target_corr,1];
                                targetCov = corr2cov([sd1;sd2],targetCorr);
                                % **********************************************
                                
                                Sigma_View(e1,e2) = targetCov(1,2); %0; % set to 0. Then the signs '>' or '<' will be decided by the following IF
                                % fill up the symmetric element (to avoid problems
                                % where this is transformed into equqlities/inequalities)
                                Sigma_View(e2,e1) = targetCov(1,2);
                                if impliedCovSign > 0 % if the proj return implied by algo Mu is > 0 I want to use scenarios where the proj ret is > than the one implied bu algo mu
                                    Sigma_ViewSign{e1,e2} = ['>'];
                                    Sigma_ViewSign{e2,e1} = ['>'];
                                elseif impliedCovSign < 0          % ... and the same idea applies here
                                    Sigma_ViewSign{e1,e2} = ['<'];
                                    Sigma_ViewSign{e2,e1} = ['<'];
                                end
                                
                                % Sigma_View(e2,e1) = Sigma_View(e1,e2); % to use the exact cov
                                
                            end
                        end
                        % Q views in the same format used for subjective views
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{1,1}).Mu = Mu_View;
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{1,1}).MuSign = Mu_ViewSign;
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{1,1}).Sigma = Sigma_View;
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{1,1}).SigmaSign = Sigma_ViewSign;
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{1,1}).RankingViews = RankingViews;
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{1,1}).RankingViewsSign = RankingViewsSign;
                        % ***********************************
                    end % if CHANGEQ
                    
                    % *********************************************************
                    
                    % ********************* CointPower ************************
                    
                case 'CointPower'
                    % with this strategy, for each coint pair, I can have
                    % at most an entry signal (buy or sell the spread) wrt
                    % each coint pair
                    disp('CointPower case in QuantViews.CheckSignalAtGivenTime.m');
                    checkSignal.CHANGEQ(1:Q.NumberOfSubjects,1) = false(Q.NumberOfSubjects,1);
                    checkSignal.UNTRIGGERQ(1:Q.NumberOfSubjects,1) = false(Q.NumberOfSubjects,1); % used to close the strategy (Friday's rule in this case)
                    
                    start_t = 1;
                    
                    % pre-assigning some of the outputs checkSignal's fields
                    % limits to the optimization limits are set
                    % globally, independently of the specific view (k)
                    checkSignal.upperWgtsLimits = optionalParam.upperWgtsLimits;
                    checkSignal.lowerWgtsLimits = optionalParam.lowerWgtsLimits;
                    nassets = optionalParam.nassets;
                    checkSignal.OPTIM = false(1);
                    checkSignal.activatedAssets = []; % used to be sure that the assets involved in the strategy are activated (this is global, for all views)
                    checkSignal.HorizonDays = Q.InputParams.HorizonDays;
                    
                    for k=1:Q.NumberOfSubjects % for each cointegrated pair
                        
                        % pre-assigning some of the outputs checkSignal's fields
                        checkSignal.equalityConstraintsFromQuantStratLHS{k} = [];
                        checkSignal.equalityConstraintsFromQuantStratRHS{k} = [];
                        
                        % tickers of the assets involved in the strategy:
                        % they must in the set universe.assets to be
                        % correctly processed.
                        tickers = Q.InputParams.Drivers.params(k).forward_tickers;
                        
                        % the whole 'TradingSystem.Data.Daily' timetable from
                        % QuantSignals.m
                        ts = Q.InputParams.Drivers.TradingSystem{k}.Data.Daily;
                        ts_dates = datenum(Q.InputParams.Drivers.TradingSystem{k}.Data.Daily.Time);
                        
                        % pre-assign NaNs to the vector Mu_View and matrix
                        % Sigma_View that will host the 2 views in terms of
                        % 1st and 2nd moment as they will be setup in the
                        % sequel
                        Mu_View = zeros(1,numel(Q.InputParams.InvariantsNamesSet)).*NaN;
                        Sigma_View = zeros(numel(Q.InputParams.InvariantsNamesSet)).*NaN;
                        Ranking_Views = [];
                        
                        fd = find(ts_dates==current_t_date); % look for the carrent date
                        
                        if isempty(fd)
                            continue;
                        end
                        
                        ft = ismember(optionalParam.IU_tickers,tickers);
                        if sum(ft)<2
                            error('QuantViews::CheckSignalAtGivenTime: not all of the assets involved in the strategy have been found in the IU');
                        end
                        assetsIdxInIU = find(ft);
                        if ts.CloseStrat_1(fd)==1
                            % if the PowerCoint strategy 1 has to be closed
                            % because of the 'Friday condition': here I
                            % want to set 0 weights for the optimal
                            % allocations wrt the 2 assets involved in the
                            % PowerCoint strategy
                            checkSignal.upperWgtsLimits(assetsIdxInIU) = 0;
                            checkSignal.lowerWgtsLimits(assetsIdxInIU) = 0;
                            % used to trigger an optimization with the 2
                            % weights above ste to 0. This
                            % checkSignal.OPTIM is global for now and not
                            % relative to a single view (when there is more
                            % than 1 view)
                            checkSignal.OPTIM = true(1);
                            continue
                        end
                        
                        signal = Q.AlgoViews_1.DynamicViews(k).signals(fd);
                        intensity = Q.AlgoViews_1.DynamicViews(k).confidenceInSignal(fd,2);
                        
                        if signal ~=0 % a signal from any of the coint pairs
                            
                            checkSignal.HorizonDays = ts.HorizonDays(fd);
                            checkSignal.CHANGEQ(k,1) = true(1);
                            % assign the weights limits given the value
                            % in Strat_1_sameWkSignal (the purpose is to dilute over time
                            % the impacts of more signals occurring in the same week)
                            % They are set globally and not wrt
                            % specific view: === TODO: THIS MUST BE
                            % REVIEWD FOR USE OF SIMULTANEOUS MULTIPLE
                            % PowerCoint strategies, otherwise it can
                            % cause inconsistencies
                            checkSignal.upperWgtsLimits(assetsIdxInIU) = Q.InputParams.Drivers.params(k).aaLimUp.*ts.Strat_1_sameWkSignal(fd);
                            checkSignal.lowerWgtsLimits(assetsIdxInIU) = Q.InputParams.Drivers.params(k).aaLimDown.*ts.Strat_1_sameWkSignal(fd);
                            % set the constraint to the optimization
                            % needed to impose equal (opposite signs)
                            % weights on the assets involved in the
                            % strategy
                            tmpeq = zeros(1,nassets);
                            tmpeq(assetsIdxInIU) = 1;
                            checkSignal.equalityConstraintsFromQuantStratLHS{k} = tmpeq; % left hand side
                            checkSignal.equalityConstraintsFromQuantStratRHS{k} = 0; % right end side
                            checkSignal.activatedAssets = [checkSignal.activatedAssets,assetsIdxInIU];
                            
                            % **********  transform views into  **********
                            % ********   equalites/inequalities   *********
                            
                            % indices of the 2 assets within the investment
                            % universe (preserving the order they enter the
                            % coint relationship)
                            idx(1) = find(ismember(Q.InputParams.InvariantsNamesSet, strrep(tickers{1},' ', '_')));
                            idx(2) = find(ismember(Q.InputParams.InvariantsNamesSet, strrep(tickers{2},' ', '_')));
                            
                            % *****************************************
                            Returns = X_fullHistory(start_t:t,:);
                            
                            if signal==-1
                                % sell the 1st component, buy the second one
                                r1=Returns(:,idx(1));
                                r1 = r1(r1<0);
                                r2=Returns(:,idx(2));
                                r2 = r2(r2>0);
                                Mu_View(idx(1)) = prctile(r1,60);
                                Mu_View(idx(2)) = prctile(r2,40);
                                
                                Mu_ViewSign{1,idx(1)} = ['<'];
                                Mu_ViewSign{1,idx(2)} = ['>'];
                                
                            elseif signal==1
                                % buy the 1st component, sell the second one
                                r1=Returns(:,idx(1));
                                r1 = r1(r1>0);
                                r2=Returns(:,idx(2));
                                r2 = r2(r2<0);
                                Mu_View(idx(1)) = prctile(r1,40);
                                Mu_View(idx(2)) = prctile(r2,60);
                                
                                Mu_ViewSign{1,idx(1)} = ['>'];
                                Mu_ViewSign{1,idx(2)} = ['<'];
                                
                            end
                            % ******************************
                            
                        end % if there is a signal
                        
                        checkSignal.activatedAssets = unique(checkSignal.activatedAssets);
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{k,1}).Mu = Mu_View.*Q.InputParams.HorizonDays;
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{k,1}).Sigma = Sigma_View.*Q.InputParams.HorizonDays;
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{k,1}).MuSign = Mu_ViewSign;
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{k,1}).SigmaSign = [];
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{1,1}).RankingViews = RankingViews;
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{1,1}).RankingViewsSign = RankingViewsSign;
                    end % k-loop (# subject = no of cointegrating pairs)
                    
                    % CONFIDENCE IN VIEWS SETTINGS: THIS 'PIECE' OF CODE
                    % SHOULD BE USED AND ADAPTED TO ALL OF THE VIEWS
                    % GENERATORS
                    % if a single number is provided than it is
                    % splitted between ACTIVE subjects. Otherwise a
                    % vector must be provided whose dim must equal the
                    % no of subjects expressing views. In this case
                    % this vector will be used regarless of whether the
                    % view expressed by a given subject is active or
                    % not
                    if  ~isempty(CONFIDENCE)
                        % IMPORTANT: when the conf level is computed
                    	% endogenousely
                        conf = CONFIDENCE;
                    else
                        % OTHERWISE: the one (or ones) provided with the
                        % initial settings are used
                        conf = Q.InputParams.confInViews;
                    end
                    if numel(conf) == 1
                        Q.ConfInQuantViews = zeros(1,Q.NumberOfSubjects);
                        activeSubjects = find(checkSignal.CHANGEQ);
                        n_activeSubjects = numel(activeSubjects);
                        Q.ConfInQuantViews(activeSubjects) = conf./n_activeSubjects;
                    elseif numel(conf) == Q.NumberOfSubjects
                        Q.ConfInQuantViews = conf;
                    else
                        error('Conf in Q views must be a scalar or a vector of dim [1 x no of subjects expressing views]');
                    end
                    % to guarantee that the sum of conf levels equals the
                    % tot conf in quant views as defined by the initial
                    % parameters (Q.InputParams.confInViews)
                    Q.ConfInQuantViews = sum(Q.InputParams.confInViews).*Q.ConfInQuantViews./sum(Q.ConfInQuantViews)
                    
                    % ******************* CointPower End ******************
                    
                    % *************** PairCointegration *******************
                case 'PairCointegration'
                    
                    % with this strategy, for each coint pair, I can have
                    % at most an entry signal (buy or sell the spread) wrt
                    % each coint pair
                    disp('CointPower case in QuantViews.CheckSignalAtGivenTime.m');
                    checkSignal.CHANGEQ(1:Q.NumberOfSubjects,1) = false(Q.NumberOfSubjects,1);
                    checkSignal.UNTRIGGERQ(1:Q.NumberOfSubjects,1) = false(Q.NumberOfSubjects,1); % used to close the strategy (Friday's rule in this case)
                    
                    start_t = 1;
                    
                    % pre-assigning some of the outputs checkSignal's fields
                    % limits to the optimization limits are set
                    % globally, independently of the specific view (k)
                    checkSignal.upperWgtsLimits = optionalParam.upperWgtsLimits;
                    checkSignal.lowerWgtsLimits = optionalParam.lowerWgtsLimits;
                    nassets = optionalParam.nassets;
                    checkSignal.OPTIM = false(1);
                    checkSignal.activatedAssets = []; % used to be sure that the assets involved in the strategy are activated (this is global, for all views)
                    checkSignal.HorizonDays = Q.InputParams.HorizonDays;
                    
                    if isfield(optionalParam,'prevCheckSignal')
                        % if already assigne by universe.Dynamic_AA_1 pass
                    else
                        % otherwise need to be assigned to avoid triggering
                        % an exception
                        optionalParam.prevCheckSignal = [];
                    end
                    
                    for k=1:Q.NumberOfSubjects % for each cointegrated pair
                        
                        % pre-assigning some of the outputs checkSignal's fields
                        checkSignal.equalityConstraintsFromQuantStratLHS{k} = [];
                        checkSignal.equalityConstraintsFromQuantStratRHS{k} = [];
                        persist = Q.InputParams.Drivers.params(k).persist;
                        
                        % tickers of the assets involved in the strategy:
                        % they must in the set universe.assets to be
                        % correctly processed.
                        tickers = Q.InputParams.Drivers.params(k).tickers;
                        
                        % the whole 'TradingSystem.Data.Daily' timetable from
                        % QuantSignals.m
                        ts = Q.InputParams.Drivers.TradingSystem{k}.Data;
                        ts_dates = datenum(Q.InputParams.Drivers.TradingSystem{k}.Data.dates);
                        
                        % pre-assign NaNs to the vector Mu_View and matrix
                        % Sigma_View that will host the 2 views in terms of
                        % 1st and 2nd moment as they will be setup in the
                        % sequel
                        Mu_View = zeros(1,numel(Q.InputParams.InvariantsNamesSet)).*NaN;
                        Sigma_View = zeros(numel(Q.InputParams.InvariantsNamesSet)).*NaN;
                        RankingViews = zeros(1,numel(Q.InputParams.InvariantsNamesSet));
                        RankingViewsSign = [];
                        
                        fd = find(ts_dates==current_t_date); % look for the carrent date
                        
                        if isempty(fd)
                            continue;
                        end
                        
                        ft = ismember(optionalParam.IU_tickers,tickers);
                        if sum(ft)<2
                            error('QuantViews::CheckSignalAtGivenTime: not all of the assets involved in the strategy have been found in the IU');
                        end
                        assetsIdxInIU = find(ft);
                        % * if ts.CloseStrat_1(fd)==1
                        % * end
                        
                        signal = Q.AlgoViews_1.DynamicViews(k).signals(fd);
                        CONFIDENCE(k) = Q.AlgoViews_1.DynamicViews(k).confidenceInSignal(fd,2);
                        checkSignal.signal(k) = 0;
                        
                        if signal ~=0 ... % a signal from any of the coint pairs
                           | (signal==0 & persist==1 & ~isempty(optionalParam.prevCheckSignal)) % or current signal is off, but it was on and I want it to persist, unless a given condition occurs     
                            
                            % if the current bloack has been entered with
                            % signal==0
                            if signal==0 &  optionalParam.prevCheckSignal.CHANGEQ(k)==1
                                % if at the porevious iteration the signal
                                % was active then keep it as it was, unless
                                % a specific condition on the intensity of
                                % the signal occurs
                                
                                if abs(Q.InputParams.Drivers.TradingSystem{k}.Data.Spread(fd)) < 0.20 ...
                                        | Q.InputParams.Drivers.TradingSystem{k}.Data.hTest(fd) == 0
                                    % turn the signal off
                                    signal = 0;
                                    goahead = false(1);
                                else
                                    goahead = true(1);
                                    signal = optionalParam.prevCheckSignal.signal(k);
                                end
                            elseif signal==0 &  optionalParam.prevCheckSignal.CHANGEQ(k)==0
                                goahead = false(1);
                            elseif signal~=0    
                                goahead = true(1);
                            end
                            
                            if goahead
                                checkSignal.signal(k) = signal;
                                checkSignal.HorizonDays = ts.HorizonDays(fd);
                                checkSignal.CHANGEQ(k,1) = true(1);
                                % assign the weights limits given the value
                                checkSignal.upperWgtsLimits(assetsIdxInIU) = Q.InputParams.Drivers.params(k).aaLimUp;
                                checkSignal.lowerWgtsLimits(assetsIdxInIU) = Q.InputParams.Drivers.params(k).aaLimDown;
                                % set the constraint to the optimization
                                % needed to impose equal (opposite signs)
                                % weights on the assets involved in the
                                % strategy
                                % ***************  NOTE USED HERE *************
                                % * tmpeq = zeros(1,nassets);
                                % * tmpeq(assetsIdxInIU) = 1;
                                % * checkSignal.equalityConstraintsFromQuantStratLHS{k} = tmpeq; % left hand side
                                % * checkSignal.equalityConstraintsFromQuantStratRHS{k} = 0; % right end side
                                % * checkSignal.activatedAssets = [checkSignal.activatedAssets,assetsIdxInIU];
                                
                                checkSignal.equalityConstraintsFromQuantStratLHS{k} = []; % left hand side
                                checkSignal.equalityConstraintsFromQuantStratRHS{k} = []; % right end side
                                
                                % **********  transform views into  **********
                                % ********   equalites/inequalities   *********
                                
                                % indices of the 2 assets within the investment
                                % universe (preserving the order they enter the
                                % coint relationship)
                                idx(1) = find(ismember(Q.InputParams.InvariantsNamesSet, strrep(tickers{1},' ', '_')));
                                idx(2) = find(ismember(Q.InputParams.InvariantsNamesSet, strrep(tickers{2},' ', '_')));
                                
                                % EXPRESSED IN TERMS OF RANKINGS HERE
                                % e.g. 1st asset > 2nd asset or vicecersa
                                RankingViews(idx(1)) = 1;
                                RankingViews(idx(2)) = -1;
                                
                                % *****************************************
                                
                                if signal==-1
                                    RankingViewsSign = '<';
                                elseif signal==1
                                    RankingViewsSign = '>';
                                end
                                % ******************************
                            end % if goahead
                        end % if there is a signal
                   
                        
                        checkSignal.activatedAssets = unique(checkSignal.activatedAssets);
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{k,1}).Mu = Mu_View.*Q.InputParams.HorizonDays;
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{k,1}).Sigma = Sigma_View.*Q.InputParams.HorizonDays;
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{k,1}).MuSign = Mu_ViewSign;
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{k,1}).SigmaSign = [];
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{k,1}).RankingViews = RankingViews;
                        Q.QViews.(Q.AlgoViews_1.ViewsNames{k,1}).RankingViewsSign = RankingViewsSign;
                        
                    end % k-loop (# subject = no of cointegrating pairs)
                    
                    % CONFIDENCE IN VIEWS SETTINGS: THIS 'PIECE' OF CODE
                    % SHOULD BE USED AND ADAPTED TO ALL OF THE VIEWS
                    % GENERATORS
                    % if a single number is provided than it is
                    % splitted between ACTIVE subjects. Otherwise a
                    % vector must be provided whose dim must equal the
                    % no of subjects expressing views. In this case
                    % this vector will be used regarless of whether the
                    % view expressed by a given subject is active or
                    % not
                    if  ~isempty(CONFIDENCE)
                        % IMPORTANT: when the conf level is computed
                    	% endogenousely
                        conf = CONFIDENCE;
                    else
                        % OTHERWISE: the one (or ones) provided with the
                        % initial settings are used
                        conf = Q.InputParams.confInViews;
                    end
                    if numel(conf) == 1
                        Q.ConfInQuantViews = zeros(1,Q.NumberOfSubjects);
                        activeSubjects = find(checkSignal.CHANGEQ);
                        n_activeSubjects = numel(activeSubjects);
                        Q.ConfInQuantViews(activeSubjects) = conf./n_activeSubjects;
                    elseif numel(conf) == Q.NumberOfSubjects
                        Q.ConfInQuantViews = conf;
                    else
                        error('Conf in Q views must be a scalar or a vector of dim [1 x no of subjects expressing views]');
                    end
                    % to guarantee that the sum of conf levels equals the
                    % tot conf in quant views as defined by the initial
                    % parameters (Q.InputParams.confInViews)
                    Q.ConfInQuantViews = sum(Q.InputParams.confInViews).*Q.ConfInQuantViews./sum(Q.ConfInQuantViews)
                    % ************* PairCointegration End *****************
                    
            end % END switch based on quant strategy
            
        end % CheckSignalAtGivenTime
        
    end % public methods
    
end % class definition




